<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>build-tools</title><link>https://buildtools.io/</link><description>Recent content on build-tools</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>© 2019 buildtool</copyright><atom:link href="https://buildtools.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Introduction</title><link>https://buildtools.io/introduction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://buildtools.io/introduction/</guid><description>build-tools is a set of highly opinionated tools for creating and building components/services into docker images and deploying them to Kubernetes clusters.
By following the conventions set by the tools, building and deploying applications is made simpler.
The only hard requirement is to provide a Dockerfile which describes how to build and run your application.
The configuration needed is done by environment variables (most likely for CI/CD) and yaml files (for local use).</description></item><item><title>Installation</title><link>https://buildtools.io/installation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://buildtools.io/installation/</guid><description>You can install the pre-compiled binary (in several different ways), use Docker or compile from source.
Installation pre-built binaries Homebrew tap
$ brew install buildtool/taps/build-tools Shell script
$ curl -sfL https://raw.githubusercontent.com/buildtool/build-tools/master/install.sh | sh Manually
Download the pre-compiled binaries from the releases page and copy to the desired location.
Docker You can also use it within a Docker container. To do that, you’ll need to execute something more-or-less like the following:</description></item><item><title>Conventions</title><link>https://buildtools.io/conventions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://buildtools.io/conventions/</guid><description>The project folder must be a Git repository, with a least one commit Dockerfile must be present in the root of the project directory (this can be overriden with flags). The Dockerfile will be used to build the project into a runnable docker image. Kubernetes descriptor files must be located in the k8s folder The name of the directory will be used as the name of the docker image (if running in CI ENV variables will be used to determine the name of the project being built) The current commit id will be used as docker tag Take a look at the build-tools-example repository to try it out.</description></item><item><title>Quickstart</title><link>https://buildtools.io/quickstart/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://buildtools.io/quickstart/</guid><description>TODO</description></item><item><title>Commands</title><link>https://buildtools.io/commands/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://buildtools.io/commands/</guid><description>Available commands build Performs a docker build, using a Dockerfile to build the application and tags the resulting image. By following the conventions no additional flags are needed, but the following flags are available:
Flag Description -f/--file &amp;lt;path to Dockerfile&amp;gt; Used to override the default Dockerfile location (which is $PWD) -skiplogin Disables login to docker registry (good for local testing) -build-arg key=value Additional Docker build-arg $ build -f docker/Dockerfile.</description></item><item><title>Continuous Integration</title><link>https://buildtools.io/ci/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://buildtools.io/ci/</guid><description>Commands recognize which CI/CD environment they are executed in based on which environment variables are present.
Environment variable CI/CD BUILDKITE_PIPELINE_SLUG Buildkite CI_PROJECT_NAME Gitlab CI RUNNER_WORKSPACE Github Actions TEAMCITY_PROJECT_NAME TeamCity BUILD_REPOSITORY_NAME Azure Devops Examples Buildkite Buildkite is configured with .buildkite/pipeline.yml file in your project.
steps: - command: |- build push label: build - wait - command: |- ${BUILD_TOOLS_PATH}/deploy staging label: Deploy to staging branches: &amp;#34;master&amp;#34; - block: &amp;#34;:rocket: Release PROD&amp;#34; branches: &amp;#34;master&amp;#34; - command: |- ${BUILD_TOOLS_PATH}/deploy prod label: Deploy PROD branches: &amp;#34;master&amp;#34; Gitlab CI Gitlab CI is configured with a .</description></item><item><title>Configuration files</title><link>https://buildtools.io/config/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://buildtools.io/config/</guid><description>Configuration and setup is done in .buildtools.yaml files. Those files must be present in the project folder or upwards in the directory structure. This lets you create a common .buildtools.yaml file to be used for a set of projects. The .buildtools.yaml files will be merged together, and settings from file closest to the project being used first.
Example:
$ pwd ~/source/ $ tree . ├── customer1 │ ├── project1 │ └── project2 └── customer2 └── project1 Here we can choose to put a .</description></item><item><title>Registry</title><link>https://buildtools.io/registry/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://buildtools.io/registry/</guid><description>The registry key in .buildtools.yaml defines the docker registry used for the project. This will primarily be used for CI pipelines to push built docker images. Locally it can be used to build images with correct tags, making it possible to deploy locally built images.
The following registries are supported:
Config key Container registry dockerhub Docker hub ecr AWS Elastic Container Registry github Github package registry gitlab Gitlab container registry quay Quay docker registry dockerhub Parameter Description Env variable namespace The namespace to publish to DOCKERHUB_NAMESPACE username User to authenticate DOCKERHUB_USERNAME password Password for user authentication DOCKERHUB_PASSWORD ecr AWS Credentials must be supplied as ENV variables, read more here.</description></item><item><title>Environments</title><link>https://buildtools.io/environments/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://buildtools.io/environments/</guid><description>environments specifies the different deployment &amp;lsquo;targets&amp;rsquo; to use for the project. The environments matches Kubernetes cluster configurations to deploy projects. Setting up Kubernetes contexts and namespaces is not handled by these tools.
The only required configuration is context.
environments: &amp;lt;name&amp;gt;: context: namespace: kubeconfig: Parameter Default Description context Which context in the Kubernetes configuration to use namespace default Specific namespace to deploy to kubeconfig value of KUBECONFIG ENV variable Full path to a specific kubeconfig file to use</description></item><item><title>Kubernetes</title><link>https://buildtools.io/k8s/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://buildtools.io/k8s/</guid><description>here must be a k8s directory in the root of your project file. This directory contains all the yaml files used to describe the Kubernetes deployment tasks needed to run this service. Environment specific files are handled by using a -&amp;lt;environment&amp;gt; suffix, i.e. ingress-prod.yaml.
$ cd projecct $ tree . └── k8s ├── deploy.yaml ├── ingress-local.yaml ├── ingress-prod.yaml └── setup-local.sh Files with a .yaml suffix will be applied to the Kubernetes cluster.</description></item><item><title>Contributing</title><link>https://buildtools.io/contributing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://buildtools.io/contributing/</guid><description>Work in progress&amp;hellip;. Check the CONTRIBUTING.md</description></item></channel></rss>