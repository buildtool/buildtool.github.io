{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":"python","separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"contributing/","text":"Contributing \u00b6 Work in progress.... Check the CONTRIBUTING.md","title":"Contributing"},{"location":"contributing/#contributing","text":"Work in progress.... Check the CONTRIBUTING.md","title":"Contributing"},{"location":"conventions/","text":"Conventions \u00b6 The project folder must be a Git repository, with a least one commit Dockerfile should be present in the root of the project directory (this can be overridden with flags ). The Dockerfile will be used to build the project into a runnable docker image. Kubernetes descriptor files must be located in the k8s folder (only needed for deploy and promote ) The k8s folder can also contain custom scripts that should be run during deployment The name of the directory will be used as the name of the application (if running in CI ENV variables will be used to determine the name of the project being built) The current commit id will be used as docker tag The current branch will be used as docker tag. If you're on the master or main branch the docker image will also be tagged latest . The latest tag will also be pushed in that case. Targets (deployment targets) are configured in .buildtools.yaml file(s) .buildtools.yaml file(s) will be merged together hierarchically and can be used for multiple projects Targets names can be used to use different k8s files for different deployment targets","title":"Conventions"},{"location":"conventions/#conventions","text":"The project folder must be a Git repository, with a least one commit Dockerfile should be present in the root of the project directory (this can be overridden with flags ). The Dockerfile will be used to build the project into a runnable docker image. Kubernetes descriptor files must be located in the k8s folder (only needed for deploy and promote ) The k8s folder can also contain custom scripts that should be run during deployment The name of the directory will be used as the name of the application (if running in CI ENV variables will be used to determine the name of the project being built) The current commit id will be used as docker tag The current branch will be used as docker tag. If you're on the master or main branch the docker image will also be tagged latest . The latest tag will also be pushed in that case. Targets (deployment targets) are configured in .buildtools.yaml file(s) .buildtools.yaml file(s) will be merged together hierarchically and can be used for multiple projects Targets names can be used to use different k8s files for different deployment targets","title":"Conventions"},{"location":"faq/","text":"Frequently Asked Questions \u00b6 Or stuff just good-to-know... What happened to X-action? \u00b6 We deprecated the build, push, deploy Github actions in favour of the new setup-buildtools-action Dealing with different docker versions \u00b6 buildtools defaults to using the latest version of the docker client (the actual version is determined by the docker client library that is used). This might cause issues if your docker server is running an older version. Errors like: Error response from daemon: client version 1 .41 is too new. Maximum supported API version is 1 .40 The docker client version can be specified with the env variable DOCKER_API_VERSION Depending on your setup you might be able to use export somewhere \"globally\" export DOCKER_API_VERSION = 1 .40 Or just use it when running the actual command DOCKER_API_VERSION = 1 .40 build","title":"Frequently Asked Questions"},{"location":"faq/#frequently-asked-questions","text":"Or stuff just good-to-know...","title":"Frequently Asked Questions"},{"location":"faq/#what-happened-to-x-action","text":"We deprecated the build, push, deploy Github actions in favour of the new setup-buildtools-action","title":"What happened to X-action?"},{"location":"faq/#dealing-with-different-docker-versions","text":"buildtools defaults to using the latest version of the docker client (the actual version is determined by the docker client library that is used). This might cause issues if your docker server is running an older version. Errors like: Error response from daemon: client version 1 .41 is too new. Maximum supported API version is 1 .40 The docker client version can be specified with the env variable DOCKER_API_VERSION Depending on your setup you might be able to use export somewhere \"globally\" export DOCKER_API_VERSION = 1 .40 Or just use it when running the actual command DOCKER_API_VERSION = 1 .40 build","title":"Dealing with different docker versions"},{"location":"installation/","text":"Installation \u00b6 You can install the pre-compiled binary (in several different ways), use Docker or compile from source. Installation pre-built binaries \u00b6 Homebrew tap $ brew install buildtool/taps/build-tools Shell script $ curl -sfL https://raw.githubusercontent.com/buildtool/build-tools/main/install.sh | sh Manually Download the pre-compiled binaries from the releases page and copy to the desired location. Running with Docker \u00b6 You can also use it within a Docker container. To do that, you\u2019ll need to execute something more-or-less like the following: $ docker run --rm --privileged \\ -v $PWD :/repo \\ -v /var/run/docker.sock:/var/run/docker.sock \\ -w /repo \\ -e DOCKER_USERNAME \\ -e DOCKER_PASSWORD \\ buildtool/build-tools build Compiling from source \u00b6 Here you have two options: If you want to contribute to the project, please follow the steps on our contributing guide . If you just want to build from source for whatever reason, follow these steps: Clone: git clone https://github.com/buildtool/build-tools cd build-tools Get the dependencies: go get ./... Build: go build ./cmd/build/build.go Verify it works: ./build --version","title":"Installation"},{"location":"installation/#installation","text":"You can install the pre-compiled binary (in several different ways), use Docker or compile from source.","title":"Installation"},{"location":"installation/#installation-pre-built-binaries","text":"Homebrew tap $ brew install buildtool/taps/build-tools Shell script $ curl -sfL https://raw.githubusercontent.com/buildtool/build-tools/main/install.sh | sh Manually Download the pre-compiled binaries from the releases page and copy to the desired location.","title":"Installation pre-built binaries"},{"location":"installation/#running-with-docker","text":"You can also use it within a Docker container. To do that, you\u2019ll need to execute something more-or-less like the following: $ docker run --rm --privileged \\ -v $PWD :/repo \\ -v /var/run/docker.sock:/var/run/docker.sock \\ -w /repo \\ -e DOCKER_USERNAME \\ -e DOCKER_PASSWORD \\ buildtool/build-tools build","title":"Running with Docker"},{"location":"installation/#compiling-from-source","text":"Here you have two options: If you want to contribute to the project, please follow the steps on our contributing guide . If you just want to build from source for whatever reason, follow these steps: Clone: git clone https://github.com/buildtool/build-tools cd build-tools Get the dependencies: go get ./... Build: go build ./cmd/build/build.go Verify it works: ./build --version","title":"Compiling from source"},{"location":"introduction/","text":"Introduction \u00b6 build-tools is a set of highly opinionated tools for creating and building components/services into docker images and deploying them to Kubernetes clusters. By following the conventions set by the tools, building and deploying applications is made simpler. It streamlines the process of building and deploying using the same commands on your local development machine and in a CI/CD pipeline. The basic usage is build , push and deploy . This will build a docker image of your code using your provided Dockerfile making it possible to customize the actual build process. The built image is then pushed to a Docker Registry of your choosing. This is of course optional, but a necessary step to be able to deploy the built image on a (non-local) Kubernetes cluster. Finally, the code is deployed to the Kubernetes cluster using the provided descriptor files.","title":"Introduction"},{"location":"introduction/#introduction","text":"build-tools is a set of highly opinionated tools for creating and building components/services into docker images and deploying them to Kubernetes clusters. By following the conventions set by the tools, building and deploying applications is made simpler. It streamlines the process of building and deploying using the same commands on your local development machine and in a CI/CD pipeline. The basic usage is build , push and deploy . This will build a docker image of your code using your provided Dockerfile making it possible to customize the actual build process. The built image is then pushed to a Docker Registry of your choosing. This is of course optional, but a necessary step to be able to deploy the built image on a (non-local) Kubernetes cluster. Finally, the code is deployed to the Kubernetes cluster using the provided descriptor files.","title":"Introduction"},{"location":"quickstart/","text":"Quickstart \u00b6 Pre requisites: \u00b6 In order to work with these tools you need: Buildtools installed (of course) Docker - read more about options here Kubernetes - if you're using for example Docker for Mac Kubernetes can easily be enabled. In this example we will build, push and deploy a sample Go project. Create a Git repository and add a single main package with a http server: mkdir quickstart cd quickstart git init // main.go package main import ( \"fmt\" \"net/http\" ) func main () { http . HandleFunc ( \"/\" , HelloServer ) http . ListenAndServe ( \":8080\" , nil ) } func HelloServer ( w http . ResponseWriter , r * http . Request ) { fmt . Fprintf ( w , \"Hello, %s!\" , r . URL . Path [ 1 :]) } Add a Dockerfile describing how to build your code: # Dockerfile FROM golang:1.15 as build WORKDIR /build ADD . /build RUN GOOS = linux GOARCH = amd64 go build main.go FROM debian:buster-slim COPY --from = build /build/main / CMD [ \"/main\" ] Add the files to source control and commit: git add . git commit -m \"Init\" Build the docker image: build After the build completes you should see output like ... Successfully tagged noregistry/quickstart:latest Try to run your newly built docker image: docker run --rm -p 8080 :8080 noregistry/quickstart:latest and try to access it: curl localhost:8080/buildtools You should see a response like: Hello, buildtools! Let's try to deploy it to our local Kubernetes cluster, in order for this to work we need a Kubernetes descriptor file. Create a k8s folder and a file deploy.yaml : # k8s/deploy.yaml apiVersion: apps/v1 kind: Deployment metadata: name: quickstart labels: app: quickstart spec: replicas: 1 selector: matchLabels: app: quickstart template: metadata: labels: app: quickstart spec: containers: - name: quickstart imagePullPolicy: IfNotPresent image: noregistry/quickstart: ${ COMMIT } This will create Kubernetes deployment , basically starting your application inside the Kubernetes cluster. deploy --context docker-desktop kubectl --context docker-desktop get pods quickstart-b4c5bc467-lqk6r 1 /1 Running 0 3s","title":"Quickstart"},{"location":"quickstart/#quickstart","text":"","title":"Quickstart"},{"location":"quickstart/#pre-requisites","text":"In order to work with these tools you need: Buildtools installed (of course) Docker - read more about options here Kubernetes - if you're using for example Docker for Mac Kubernetes can easily be enabled. In this example we will build, push and deploy a sample Go project. Create a Git repository and add a single main package with a http server: mkdir quickstart cd quickstart git init // main.go package main import ( \"fmt\" \"net/http\" ) func main () { http . HandleFunc ( \"/\" , HelloServer ) http . ListenAndServe ( \":8080\" , nil ) } func HelloServer ( w http . ResponseWriter , r * http . Request ) { fmt . Fprintf ( w , \"Hello, %s!\" , r . URL . Path [ 1 :]) } Add a Dockerfile describing how to build your code: # Dockerfile FROM golang:1.15 as build WORKDIR /build ADD . /build RUN GOOS = linux GOARCH = amd64 go build main.go FROM debian:buster-slim COPY --from = build /build/main / CMD [ \"/main\" ] Add the files to source control and commit: git add . git commit -m \"Init\" Build the docker image: build After the build completes you should see output like ... Successfully tagged noregistry/quickstart:latest Try to run your newly built docker image: docker run --rm -p 8080 :8080 noregistry/quickstart:latest and try to access it: curl localhost:8080/buildtools You should see a response like: Hello, buildtools! Let's try to deploy it to our local Kubernetes cluster, in order for this to work we need a Kubernetes descriptor file. Create a k8s folder and a file deploy.yaml : # k8s/deploy.yaml apiVersion: apps/v1 kind: Deployment metadata: name: quickstart labels: app: quickstart spec: replicas: 1 selector: matchLabels: app: quickstart template: metadata: labels: app: quickstart spec: containers: - name: quickstart imagePullPolicy: IfNotPresent image: noregistry/quickstart: ${ COMMIT } This will create Kubernetes deployment , basically starting your application inside the Kubernetes cluster. deploy --context docker-desktop kubectl --context docker-desktop get pods quickstart-b4c5bc467-lqk6r 1 /1 Running 0 3s","title":"Pre requisites:"},{"location":"ci/azure/","text":"Azure Devops \u00b6 Azure Devops is configured with a azure-pipelines.yml file in your project. resources : containers : - container : build-tools image : buildtool/build-tools:latest jobs : - job : build_and_deploy pool : vmImage : 'Ubuntu 16.04' container : build-tools steps : - script : | build push name : build env : QUAY_PASSWORD : $(QUAY_PASSWORD) - script : deploy staging name : deploy_staging condition : succeeded()","title":"Azure Devops"},{"location":"ci/azure/#azure-devops","text":"Azure Devops is configured with a azure-pipelines.yml file in your project. resources : containers : - container : build-tools image : buildtool/build-tools:latest jobs : - job : build_and_deploy pool : vmImage : 'Ubuntu 16.04' container : build-tools steps : - script : | build push name : build env : QUAY_PASSWORD : $(QUAY_PASSWORD) - script : deploy staging name : deploy_staging condition : succeeded()","title":"Azure Devops"},{"location":"ci/buildkite/","text":"Buildkite \u00b6 Buildkite is configured with .buildkite/pipeline.yml file in your project. Buildkite plugin \u00b6 Using the Buildkite plugin for buildtools is probably the simplest way steps : - command : build label : build plugins : - buildtool/buildtools : - wait - command : push label : push plugins : - buildtool/buildtools : - block : \":rocket: Release PROD\" branches : \"main\" - command : deploy prod label : Deploy PROD branches : \"main\" plugins : - buildtool/buildtools : config : s3://my-buildkite-secrets/configs/myapp/env Docker plugin \u00b6 build-tools can also be used with the Buildkite docker-plugin steps : - command : |- build push label : build plugins : - docker#v3.3.0 : image : buildtool/build-tools volumes : - \"/var/run/docker.sock:/var/run/docker.sock\" propagate-environment : true - wait - block : \":rocket: Release PROD\" branches : \"main\" - command : |- deploy prod label : Deploy PROD branches : \"main\" plugins : - docker#v3.3.0 : image : buildtool/build-tools volumes : - \"/var/run/docker.sock:/var/run/docker.sock\" propagate-environment : true","title":"Buildkite"},{"location":"ci/buildkite/#buildkite","text":"Buildkite is configured with .buildkite/pipeline.yml file in your project.","title":"Buildkite"},{"location":"ci/buildkite/#buildkite-plugin","text":"Using the Buildkite plugin for buildtools is probably the simplest way steps : - command : build label : build plugins : - buildtool/buildtools : - wait - command : push label : push plugins : - buildtool/buildtools : - block : \":rocket: Release PROD\" branches : \"main\" - command : deploy prod label : Deploy PROD branches : \"main\" plugins : - buildtool/buildtools : config : s3://my-buildkite-secrets/configs/myapp/env","title":"Buildkite plugin"},{"location":"ci/buildkite/#docker-plugin","text":"build-tools can also be used with the Buildkite docker-plugin steps : - command : |- build push label : build plugins : - docker#v3.3.0 : image : buildtool/build-tools volumes : - \"/var/run/docker.sock:/var/run/docker.sock\" propagate-environment : true - wait - block : \":rocket: Release PROD\" branches : \"main\" - command : |- deploy prod label : Deploy PROD branches : \"main\" plugins : - docker#v3.3.0 : image : buildtool/build-tools volumes : - \"/var/run/docker.sock:/var/run/docker.sock\" propagate-environment : true","title":"Docker plugin"},{"location":"ci/ci/","text":"Continuous Integration \u00b6 Commands recognize which CI/CD environment they are executed in based on which environment variables are present. The following variables are checked to determine which CI/CD tool that we run under. Environment variable CI/CD BUILDKITE_PIPELINE_SLUG Buildkite CI_PROJECT_NAME Gitlab CI RUNNER_WORKSPACE Github Actions TEAMCITY_PROJECT_NAME TeamCity BUILD_REPOSITORY_NAME Azure Devops","title":"About"},{"location":"ci/ci/#continuous-integration","text":"Commands recognize which CI/CD environment they are executed in based on which environment variables are present. The following variables are checked to determine which CI/CD tool that we run under. Environment variable CI/CD BUILDKITE_PIPELINE_SLUG Buildkite CI_PROJECT_NAME Gitlab CI RUNNER_WORKSPACE Github Actions TEAMCITY_PROJECT_NAME TeamCity BUILD_REPOSITORY_NAME Azure Devops","title":"Continuous Integration"},{"location":"ci/github/","text":"Github Actions \u00b6 Build-tools can also be used within our official build-tools actions through GitHub Actions You can create a workflow by putting YAML configuration to .github/workflows/build.yml . Below is a simple snippet to use the setup-buildtools-action in your workflow: name : Buildtool on : [ push ] jobs : build : runs-on : ubuntu-latest env : GITHUB_USERNAME : dummy GITHUB_TOKEN : \"${{ secrets.GITHUB_TOKEN }}\" name : build steps : - name : Checkout uses : actions/checkout@v1 - name : build uses : buildtool/setup-buildtools-action@v0 with : # use a specific version of buildtools buildtools-version : 0.2.0-beta.1 - run : build - name : promote uses : buildtool/setup-buildtools-action@v0 # use latest released version of buildtools - run : push Read more about available commands : For detailed intructions please follow GitHub Actions syntax .","title":"Github Actions"},{"location":"ci/github/#github-actions","text":"Build-tools can also be used within our official build-tools actions through GitHub Actions You can create a workflow by putting YAML configuration to .github/workflows/build.yml . Below is a simple snippet to use the setup-buildtools-action in your workflow: name : Buildtool on : [ push ] jobs : build : runs-on : ubuntu-latest env : GITHUB_USERNAME : dummy GITHUB_TOKEN : \"${{ secrets.GITHUB_TOKEN }}\" name : build steps : - name : Checkout uses : actions/checkout@v1 - name : build uses : buildtool/setup-buildtools-action@v0 with : # use a specific version of buildtools buildtools-version : 0.2.0-beta.1 - run : build - name : promote uses : buildtool/setup-buildtools-action@v0 # use latest released version of buildtools - run : push Read more about available commands : For detailed intructions please follow GitHub Actions syntax .","title":"Github Actions"},{"location":"ci/gitlab/","text":"Gitlab CI \u00b6 Gitlab CI is configured with a .gitlab-ci.yaml file in your project. stages : - build - deploy-staging - deploy-prod variables : DOCKER_HOST : tcp://docker:2375/ image : buildtool/build-tools:latest build : stage : build services : - docker:dind script : - build - push deploy-to-staging : stage : deploy-staging when : on_success script : - echo Deploy to staging. - deploy staging environment : name : staging deploy-to-prod : stage : deploy-prod when : on_success script : - echo Deploy to PROD. - deploy prod environment : name : prod only : - main","title":"Gitlab CI"},{"location":"ci/gitlab/#gitlab-ci","text":"Gitlab CI is configured with a .gitlab-ci.yaml file in your project. stages : - build - deploy-staging - deploy-prod variables : DOCKER_HOST : tcp://docker:2375/ image : buildtool/build-tools:latest build : stage : build services : - docker:dind script : - build - push deploy-to-staging : stage : deploy-staging when : on_success script : - echo Deploy to staging. - deploy staging environment : name : staging deploy-to-prod : stage : deploy-prod when : on_success script : - echo Deploy to PROD. - deploy prod environment : name : prod only : - main","title":"Gitlab CI"},{"location":"ci/teamcity/","text":"TeamCity \u00b6 TeamCity can be configured with a .teamcity/settings.kts file in your project. import jetbrains.buildServer.configs.kotlin.v2018_2.* import jetbrains.buildServer.configs.kotlin.v2018_2.buildSteps.ScriptBuildStep import jetbrains.buildServer.configs.kotlin.v2018_2.buildSteps.script import jetbrains.buildServer.configs.kotlin.v2018_2.triggers.finishBuildTrigger import jetbrains.buildServer.configs.kotlin.v2018_2.triggers.vcs version = \"2019.1\" project { buildType ( BuildAndPush ) } object BuildAndPush : BuildType ({ name = \"BuildAndPush\" steps { script { name = \"build and push\" scriptContent = \"\"\" build && push \"\"\" . trimIndent () dockerImage = \"buildtool/buildtools\" dockerImagePlatform = ScriptBuildStep . ImagePlatform . Linux dockerPull = true dockerRunParameters = \"\"\" -v /var/run/docker.sock:/var/run/docker.sock --rm \"\"\" . trimIndent () } } triggers { vcs {} } })","title":"TeamCity"},{"location":"ci/teamcity/#teamcity","text":"TeamCity can be configured with a .teamcity/settings.kts file in your project. import jetbrains.buildServer.configs.kotlin.v2018_2.* import jetbrains.buildServer.configs.kotlin.v2018_2.buildSteps.ScriptBuildStep import jetbrains.buildServer.configs.kotlin.v2018_2.buildSteps.script import jetbrains.buildServer.configs.kotlin.v2018_2.triggers.finishBuildTrigger import jetbrains.buildServer.configs.kotlin.v2018_2.triggers.vcs version = \"2019.1\" project { buildType ( BuildAndPush ) } object BuildAndPush : BuildType ({ name = \"BuildAndPush\" steps { script { name = \"build and push\" scriptContent = \"\"\" build && push \"\"\" . trimIndent () dockerImage = \"buildtool/buildtools\" dockerImagePlatform = ScriptBuildStep . ImagePlatform . Linux dockerPull = true dockerRunParameters = \"\"\" -v /var/run/docker.sock:/var/run/docker.sock --rm \"\"\" . trimIndent () } } triggers { vcs {} } })","title":"TeamCity"},{"location":"commands/build/","text":"build \u00b6 Performs a docker build , using a Dockerfile to build the application and tags the resulting image. By following the conventions no additional flags are needed, but the following flags are available: Flag Description --file , -f <path to Dockerfile> Used to override the default Dockerfile location (which is $PWD ) --no-login Disables login to docker registry (good for local testing) --no-pull Disables pulling of remote images if they already exist (good for local testing) --build-arg key=value Additional Docker build-arg $ build --file docker/Dockerfile.build --skip-login --build-arg AUTH_TOKEN = abc Build-args \u00b6 The following [build-arg] are automatically made available: Arg Value CI_COMMIT The commit being built as exposed by CI CI_BRANCH The branch being built as exposed by CI they can be used in a Dockerfile like: FROM ubuntu ARG CI_BRANCH RUN echo \"Building $CI_BRANCH \"","title":"build"},{"location":"commands/build/#build","text":"Performs a docker build , using a Dockerfile to build the application and tags the resulting image. By following the conventions no additional flags are needed, but the following flags are available: Flag Description --file , -f <path to Dockerfile> Used to override the default Dockerfile location (which is $PWD ) --no-login Disables login to docker registry (good for local testing) --no-pull Disables pulling of remote images if they already exist (good for local testing) --build-arg key=value Additional Docker build-arg $ build --file docker/Dockerfile.build --skip-login --build-arg AUTH_TOKEN = abc","title":"build"},{"location":"commands/build/#build-args","text":"The following [build-arg] are automatically made available: Arg Value CI_COMMIT The commit being built as exposed by CI CI_BRANCH The branch being built as exposed by CI they can be used in a Dockerfile like: FROM ubuntu ARG CI_BRANCH RUN echo \"Building $CI_BRANCH \"","title":"Build-args"},{"location":"commands/deploy/","text":"deploy \u00b6 Deploys the built application to a Kubernetes cluster. Normal usage deploy <target> , but additional flags can be used to override: Flag Description --context , -c Use a different context than the one found in configuration --namespace , -n Use a different namespace than the one found in configuration --timeout , -t Override the default deployment waiting time for completion (default 2 minutes). 0 means forever, all other values should contain a corresponding time unit (e.g. 1s, 2m, 3h) --tag Override the default tag to use (instead of the current commit tag or the value from CI) Default usage, with .buildtools.yaml file \u00b6 Only the target name has to be specified $ deploy local Overriding namespace from config: \u00b6 $ deploy --namespace test local Usage without .buildtools.yaml file \u00b6 In this case we need to at least specify the Kubernetes context to use for deployment: $ deploy --context docker-desktop This will set the namespace to default Specifying namespace: \u00b6 $ deploy --context docker-desktop --namespace test","title":"deploy"},{"location":"commands/deploy/#deploy","text":"Deploys the built application to a Kubernetes cluster. Normal usage deploy <target> , but additional flags can be used to override: Flag Description --context , -c Use a different context than the one found in configuration --namespace , -n Use a different namespace than the one found in configuration --timeout , -t Override the default deployment waiting time for completion (default 2 minutes). 0 means forever, all other values should contain a corresponding time unit (e.g. 1s, 2m, 3h) --tag Override the default tag to use (instead of the current commit tag or the value from CI)","title":"deploy"},{"location":"commands/deploy/#default-usage-with-buildtoolsyaml-file","text":"Only the target name has to be specified $ deploy local","title":"Default usage, with .buildtools.yaml file"},{"location":"commands/deploy/#overriding-namespace-from-config","text":"$ deploy --namespace test local","title":"Overriding namespace from config:"},{"location":"commands/deploy/#usage-without-buildtoolsyaml-file","text":"In this case we need to at least specify the Kubernetes context to use for deployment: $ deploy --context docker-desktop This will set the namespace to default","title":"Usage without .buildtools.yaml file"},{"location":"commands/deploy/#specifying-namespace","text":"$ deploy --context docker-desktop --namespace test","title":"Specifying namespace:"},{"location":"commands/kubecmd/","text":"kubecmd \u00b6 Generates a kubectl command, using the configuration from .buildtools.yaml if found. Normal usage kubecmd <target> , but additional flags can be used to override: Flag Description --context , -c Use a different context than the one found in configuration --namespace , -n Use a different namespace than the one found in configuration Default usage, with .buildtools.yaml file \u00b6 Only the target name has to be specified $ kubecmd local kubectl --context docker-desktop --namespace default Overriding namespace from config: \u00b6 $ kubecmd --namespace test local kubectl --context docker-desktop --namespace test","title":"kubecmd"},{"location":"commands/kubecmd/#kubecmd","text":"Generates a kubectl command, using the configuration from .buildtools.yaml if found. Normal usage kubecmd <target> , but additional flags can be used to override: Flag Description --context , -c Use a different context than the one found in configuration --namespace , -n Use a different namespace than the one found in configuration","title":"kubecmd"},{"location":"commands/kubecmd/#default-usage-with-buildtoolsyaml-file","text":"Only the target name has to be specified $ kubecmd local kubectl --context docker-desktop --namespace default","title":"Default usage, with .buildtools.yaml file"},{"location":"commands/kubecmd/#overriding-namespace-from-config","text":"$ kubecmd --namespace test local kubectl --context docker-desktop --namespace test","title":"Overriding namespace from config:"},{"location":"commands/promote/","text":"promote \u00b6 Templates deployment descriptors and promotes them to a Git-repository of choice. Normal usage promote <target> , but additional flags can be used to override: Flag Description --namespace , -n Use a different namespace than the one found in configuration --tag Override the default tag to use (instead of the current commit tag or the value from CI) --url override the URL to the Git repository where files will be generated --path override the path in the Git repository where files will be generated --user username for Git access, defaults to git --key private key for Git access, defaults to ~/.ssh/id_rsa --password password for private key, defaults to \"\" --out , -o write output to specified file instead of committing and pushing to Git Default usage, with .buildtools.yaml file \u00b6 Only the target name has to be specified $ promote local Overriding namespace from config: \u00b6 $ promote --namespace test local","title":"promote"},{"location":"commands/promote/#promote","text":"Templates deployment descriptors and promotes them to a Git-repository of choice. Normal usage promote <target> , but additional flags can be used to override: Flag Description --namespace , -n Use a different namespace than the one found in configuration --tag Override the default tag to use (instead of the current commit tag or the value from CI) --url override the URL to the Git repository where files will be generated --path override the path in the Git repository where files will be generated --user username for Git access, defaults to git --key private key for Git access, defaults to ~/.ssh/id_rsa --password password for private key, defaults to \"\" --out , -o write output to specified file instead of committing and pushing to Git","title":"promote"},{"location":"commands/promote/#default-usage-with-buildtoolsyaml-file","text":"Only the target name has to be specified $ promote local","title":"Default usage, with .buildtools.yaml file"},{"location":"commands/promote/#overriding-namespace-from-config","text":"$ promote --namespace test local","title":"Overriding namespace from config:"},{"location":"commands/push/","text":"push \u00b6 Performs a Docker push of the image created by build . By following the conventions no additional flags are needed, but the following flags are available: Flag Description --file , -f <path to Dockerfile> Used to override the default Dockerfile location (which is $PWD ) $ push --file docker/Dockerfile.build","title":"push"},{"location":"commands/push/#push","text":"Performs a Docker push of the image created by build . By following the conventions no additional flags are needed, but the following flags are available: Flag Description --file , -f <path to Dockerfile> Used to override the default Dockerfile location (which is $PWD ) $ push --file docker/Dockerfile.build","title":"push"},{"location":"config/config/","text":".buildtools.yaml \u00b6 Configuration and setup is done in .buildtools.yaml file(s). A typical configuration file consists of a registry config and a list of targets to use. Key Description registry registry registry to push to targets targets to deploy to git git configuration block gitops git repos to push descriptors to Note: Multiple files can be used for more advanced usage Example \u00b6 The following file specifies a Dockerhub registry and 2 deployment targets: local-test and staging registry : dockerhub : namespace : buildtool targets : local-test : context : docker-desktop staging : context : staging-aws-eu-west-1 namespace : my-test Configuration file from environment variables \u00b6 A .buildtools.yaml file can be created by defining an environment variable in the build pipeline named BUILDTOOLS_CONTENT . This can be useful when setting up CI/CD pipelines where the file system is not easily accessible. On MacOS the value can be created and copied to the clipboard using the following snippet: $ cat - <<EOF | base64 -w0 | pbcopy targets: local-test: context: docker-desktop EOF BUILDTOOLS_CONTENT can be either a base64 encoded string or plain text. Note: If BUILDTOOLS_CONTENT is set, no other configuration files will be used. See the following sections for information on how to configure the different parts of the configuration files.","title":".buildtools.yaml"},{"location":"config/config/#buildtoolsyaml","text":"Configuration and setup is done in .buildtools.yaml file(s). A typical configuration file consists of a registry config and a list of targets to use. Key Description registry registry registry to push to targets targets to deploy to git git configuration block gitops git repos to push descriptors to Note: Multiple files can be used for more advanced usage","title":".buildtools.yaml"},{"location":"config/config/#example","text":"The following file specifies a Dockerhub registry and 2 deployment targets: local-test and staging registry : dockerhub : namespace : buildtool targets : local-test : context : docker-desktop staging : context : staging-aws-eu-west-1 namespace : my-test","title":"Example"},{"location":"config/config/#configuration-file-from-environment-variables","text":"A .buildtools.yaml file can be created by defining an environment variable in the build pipeline named BUILDTOOLS_CONTENT . This can be useful when setting up CI/CD pipelines where the file system is not easily accessible. On MacOS the value can be created and copied to the clipboard using the following snippet: $ cat - <<EOF | base64 -w0 | pbcopy targets: local-test: context: docker-desktop EOF BUILDTOOLS_CONTENT can be either a base64 encoded string or plain text. Note: If BUILDTOOLS_CONTENT is set, no other configuration files will be used. See the following sections for information on how to configure the different parts of the configuration files.","title":"Configuration file from environment variables"},{"location":"config/files/","text":"Configuration files \u00b6 The .buildtools.yaml file(s) must be present in the project folder or upwards in the directory structure. This lets you create a common .buildtools.yaml file to be used for a set of projects. The .buildtools.yaml files will then be merged together, and settings from the file closest to the project being used first. Example: \u00b6 $ tree . \u251c\u2500\u2500 customer1 \u2502 \u251c\u2500\u2500 project1 \u2502 \u2514\u2500\u2500 project2 \u2514\u2500\u2500 customer2 \u2514\u2500\u2500 project1 Here we can choose to put a .buildtools.yaml file in the different customer directories since they (most likely) have different deployment configuration. But both project1 and project2 for cutomer1 use the same repository, so we can share that. $ cat .buildtools.yaml targets: local: context: docker-desktop $ cat customer1/.buildtools.yaml registry: dockerhub: namespace: buildtool targets: prod: context: production kubeconfig: ~/.kube/config.d/production.yaml $ cat customer1/project1/.buildtools.yaml targets: staging: context: test $ cat customer1/project2/.buildtools.yaml targets: staging: context: staging namespace: project2 $ cat customer2/project1/.buildtools.yaml targets: staging: context: local namespace: customer2 TODO Describe the different \"final\" settings","title":"Configuration files"},{"location":"config/files/#configuration-files","text":"The .buildtools.yaml file(s) must be present in the project folder or upwards in the directory structure. This lets you create a common .buildtools.yaml file to be used for a set of projects. The .buildtools.yaml files will then be merged together, and settings from the file closest to the project being used first.","title":"Configuration files"},{"location":"config/files/#example","text":"$ tree . \u251c\u2500\u2500 customer1 \u2502 \u251c\u2500\u2500 project1 \u2502 \u2514\u2500\u2500 project2 \u2514\u2500\u2500 customer2 \u2514\u2500\u2500 project1 Here we can choose to put a .buildtools.yaml file in the different customer directories since they (most likely) have different deployment configuration. But both project1 and project2 for cutomer1 use the same repository, so we can share that. $ cat .buildtools.yaml targets: local: context: docker-desktop $ cat customer1/.buildtools.yaml registry: dockerhub: namespace: buildtool targets: prod: context: production kubeconfig: ~/.kube/config.d/production.yaml $ cat customer1/project1/.buildtools.yaml targets: staging: context: test $ cat customer1/project2/.buildtools.yaml targets: staging: context: staging namespace: project2 $ cat customer2/project1/.buildtools.yaml targets: staging: context: local namespace: customer2 TODO Describe the different \"final\" settings","title":"Example:"},{"location":"config/git/","text":"Git \u00b6 The git key in .buildtools.yaml defines the git configuration used for the project. This will primarily be used for CI pipelines to push deployment descriptors images, i.e the promote command. Key Description name The name to use as author for the commit message email The email to use as author for the commit message key Override the default ssh key ( ~/.ssh/id_rsa )","title":"Git"},{"location":"config/git/#git","text":"The git key in .buildtools.yaml defines the git configuration used for the project. This will primarily be used for CI pipelines to push deployment descriptors images, i.e the promote command. Key Description name The name to use as author for the commit message email The email to use as author for the commit message key Override the default ssh key ( ~/.ssh/id_rsa )","title":"Git"},{"location":"config/gitops/","text":"Gitops \u00b6 gitops is the equivalent to targets , but determines where the generated files from promote will end up. Each <name> must be unique and contains the git push url and the path inside the repository where the files will be stored. gitops : <name> : url : path : Parameter Description url The git URL (for example git@github.com:buildtool/build-tools.git ) path Root path in the repository, files will be put under $path/$name , defaults to / Examples \u00b6 gitops : local : url : git@github.com:buildtool/build-tools.git path : local prod : url : git@github.com:buildtool/build-tools.git path : prod","title":"Gitops"},{"location":"config/gitops/#gitops","text":"gitops is the equivalent to targets , but determines where the generated files from promote will end up. Each <name> must be unique and contains the git push url and the path inside the repository where the files will be stored. gitops : <name> : url : path : Parameter Description url The git URL (for example git@github.com:buildtool/build-tools.git ) path Root path in the repository, files will be put under $path/$name , defaults to /","title":"Gitops"},{"location":"config/gitops/#examples","text":"gitops : local : url : git@github.com:buildtool/build-tools.git path : local prod : url : git@github.com:buildtool/build-tools.git path : prod","title":"Examples"},{"location":"config/k8s/","text":"Kubernetes \u00b6 Descriptor files are placed in a k8s directory in the root of your project file. This directory contains all the yaml files used to describe the Kubernetes deployment tasks needed to run this service. Target specific files are handled by using a -<target> \"suffix\", i.e. ingress-prod.yaml . Files with a .yaml suffix will be applied to the Kubernetes cluster. Files with a .sh suffix will be run on the machine executing the deploy command. This can be useful to setup secrets/configurations, mostly for local use. Note that only .sh files matching the target will be executed. All other files in k8s will be ignored by the deploy command. Example \u00b6 $ cd projecct $ tree . \u2514\u2500\u2500 k8s \u251c\u2500\u2500 deploy.yaml \u251c\u2500\u2500 ingress-local.yaml \u251c\u2500\u2500 ingress-prod.yaml \u2514\u2500\u2500 setup-local.sh \u2514\u2500\u2500 skipped.sh Given the structure above: deploy local Will apply deploy.yaml and ingress-local.yaml and execute setup-local.sh . deploy staging Will apply deploy.yaml and nothing else. deploy prod Will apply deploy.yaml and ingress-prod.yaml .","title":"Kubernetes"},{"location":"config/k8s/#kubernetes","text":"Descriptor files are placed in a k8s directory in the root of your project file. This directory contains all the yaml files used to describe the Kubernetes deployment tasks needed to run this service. Target specific files are handled by using a -<target> \"suffix\", i.e. ingress-prod.yaml . Files with a .yaml suffix will be applied to the Kubernetes cluster. Files with a .sh suffix will be run on the machine executing the deploy command. This can be useful to setup secrets/configurations, mostly for local use. Note that only .sh files matching the target will be executed. All other files in k8s will be ignored by the deploy command.","title":"Kubernetes"},{"location":"config/k8s/#example","text":"$ cd projecct $ tree . \u2514\u2500\u2500 k8s \u251c\u2500\u2500 deploy.yaml \u251c\u2500\u2500 ingress-local.yaml \u251c\u2500\u2500 ingress-prod.yaml \u2514\u2500\u2500 setup-local.sh \u2514\u2500\u2500 skipped.sh Given the structure above: deploy local Will apply deploy.yaml and ingress-local.yaml and execute setup-local.sh . deploy staging Will apply deploy.yaml and nothing else. deploy prod Will apply deploy.yaml and ingress-prod.yaml .","title":"Example"},{"location":"config/registry/","text":"Registry \u00b6 The registry key in .buildtools.yaml defines the docker registry used for the project. This will primarily be used for CI pipelines to push built docker images, i.e the push command. Locally it can be used to build images with correct tags, making it possible to deploy locally built images. Each supported registry has their own configuration keys, typically the setup looks like this: registry : <registry name> : <specific config> Supported registries \u00b6 The following registries are supported: Config key Container registry dockerhub Docker hub ecr AWS Elastic Container Registry github Github package registry gitlab Gitlab container registry quay Quay docker registry gcr Google Container registry dockerhub \u00b6 Parameter Description Env variable namespace The namespace to publish to DOCKERHUB_NAMESPACE username User to authenticate DOCKERHUB_USERNAME password Password for user authentication DOCKERHUB_PASSWORD ecr \u00b6 AWS Credentials must be supplied as ENV variables, read more here . Parameter Description Env variable url The ECR registry URL ECR_URL region Specify a region (if it's possible to derive from the url parameter it can be omitted) ECR_REGION github \u00b6 To authenticate token or a combination of username and password must be provided. Parameter Description Env variable repository The repository part of the docker image name GITHUB_REPOSITORY username User to authenticate GITHUB_USERNAME password Password for user authentication GITHUB_PASSWORD token A personal access token to use for authentication GITHUB_TOKEN gitlab \u00b6 Parameter Description Env variable registry The repository part of the docker image name CI_REGISTRY repository The repository part of the docker image name CI_REGISTRY_IMAGE token A personal access token to use for authentication CI_TOKEN quay \u00b6 Parameter Description Env variable repository The repository part of the docker image name QUAY_REPOSITORY username User to authenticate QUAY_USERNAME password Password for user authentication QUAY_PASSWORD gcr \u00b6 GCP Credentials must be supplied as service account json key (Base64 encoded) Parameter Description Env variable url The GCR registry URL GCR_URL keyfileContent ServiceAccount keyfile content GCR_KEYFILE_CONTENT","title":"Registry"},{"location":"config/registry/#registry","text":"The registry key in .buildtools.yaml defines the docker registry used for the project. This will primarily be used for CI pipelines to push built docker images, i.e the push command. Locally it can be used to build images with correct tags, making it possible to deploy locally built images. Each supported registry has their own configuration keys, typically the setup looks like this: registry : <registry name> : <specific config>","title":"Registry"},{"location":"config/registry/#supported-registries","text":"The following registries are supported: Config key Container registry dockerhub Docker hub ecr AWS Elastic Container Registry github Github package registry gitlab Gitlab container registry quay Quay docker registry gcr Google Container registry","title":"Supported registries"},{"location":"config/registry/#dockerhub","text":"Parameter Description Env variable namespace The namespace to publish to DOCKERHUB_NAMESPACE username User to authenticate DOCKERHUB_USERNAME password Password for user authentication DOCKERHUB_PASSWORD","title":"dockerhub"},{"location":"config/registry/#ecr","text":"AWS Credentials must be supplied as ENV variables, read more here . Parameter Description Env variable url The ECR registry URL ECR_URL region Specify a region (if it's possible to derive from the url parameter it can be omitted) ECR_REGION","title":"ecr"},{"location":"config/registry/#github","text":"To authenticate token or a combination of username and password must be provided. Parameter Description Env variable repository The repository part of the docker image name GITHUB_REPOSITORY username User to authenticate GITHUB_USERNAME password Password for user authentication GITHUB_PASSWORD token A personal access token to use for authentication GITHUB_TOKEN","title":"github"},{"location":"config/registry/#gitlab","text":"Parameter Description Env variable registry The repository part of the docker image name CI_REGISTRY repository The repository part of the docker image name CI_REGISTRY_IMAGE token A personal access token to use for authentication CI_TOKEN","title":"gitlab"},{"location":"config/registry/#quay","text":"Parameter Description Env variable repository The repository part of the docker image name QUAY_REPOSITORY username User to authenticate QUAY_USERNAME password Password for user authentication QUAY_PASSWORD","title":"quay"},{"location":"config/registry/#gcr","text":"GCP Credentials must be supplied as service account json key (Base64 encoded) Parameter Description Env variable url The GCR registry URL GCR_URL keyfileContent ServiceAccount keyfile content GCR_KEYFILE_CONTENT","title":"gcr"},{"location":"config/targets/","text":"Targets \u00b6 targets specifies the different 'deployment targets' to use for the project. The target match Kubernetes cluster configurations to deploy projects. Setting up Kubernetes contexts and namespaces is not handled by these tools. The only required configuration is context and <name> must be unique. targets : <name> : context : namespace : kubeconfig : Parameter Default Description context Which context in the Kubernetes configuration to use namespace default Specific namespace to deploy to kubeconfig value of KUBECONFIG environment variable Full path to a specific kubeconfig file to use The KUBECONFIG_CONTENT environment variable (probably most useful in CI/CD pipelines) can be used to provide the content of a \"kubeconfig\" file. If set, buildtools will create a temporary file with that content to use as the kubeconfig value. KUBECONFIG_CONTENT can be either a base64 encoded string or plain text. Note: the kubeconfig parameter in config file overrides both the KUBECONFIG and KUBECONFIG_CONTENT environment variables if set. Examples \u00b6 targets : local : context : docker-desktop namespace : default local-test : context : docker-desktop namespace : test","title":"Targets"},{"location":"config/targets/#targets","text":"targets specifies the different 'deployment targets' to use for the project. The target match Kubernetes cluster configurations to deploy projects. Setting up Kubernetes contexts and namespaces is not handled by these tools. The only required configuration is context and <name> must be unique. targets : <name> : context : namespace : kubeconfig : Parameter Default Description context Which context in the Kubernetes configuration to use namespace default Specific namespace to deploy to kubeconfig value of KUBECONFIG environment variable Full path to a specific kubeconfig file to use The KUBECONFIG_CONTENT environment variable (probably most useful in CI/CD pipelines) can be used to provide the content of a \"kubeconfig\" file. If set, buildtools will create a temporary file with that content to use as the kubeconfig value. KUBECONFIG_CONTENT can be either a base64 encoded string or plain text. Note: the kubeconfig parameter in config file overrides both the KUBECONFIG and KUBECONFIG_CONTENT environment variables if set.","title":"Targets"},{"location":"config/targets/#examples","text":"targets : local : context : docker-desktop namespace : default local-test : context : docker-desktop namespace : test","title":"Examples"}]}